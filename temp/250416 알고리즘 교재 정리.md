# 알고리즘

## 1. 인트로

자료구조

- 자료(data)를 담는 구조
- 접근 및 수정을 가능하게하는자료의조직, 관리, 저장
- 대량의데이터를효율적으로관리할수있는데이터의구조
- 코드 상에서 효율적으로 데이터를 처리하기위해 데이터특성에 따라 체계적으로 데이터를 구조화해야함

일상생활에서의예 - 자료구조

- 매표소의 줄 - 큐
- 계획 리스트 - 리스트
- 책을 쌓아두는 것 - 스택
- 영어사전 - 탐색구조
- 지도 - 그래프
- 조직도 - 트리

알고리즘

- 어떤문제를해결하기위한방법의절차
- 컴퓨터과학, 및수학등의분야에서어떠한문제를풀어내기위해정해진일련의절차나방법을공식화한형태로표현한것

기본형

- 순차구조 : 처음부터순서대로처리함
- 선택구조 : 조건식으로판단하여실행할처리를전환함
- 반복구조 : 조건을만족하는동안같은처리를반복함7알고리즘실무/1주차

기술방법

- 순서도 : 도형기호를사용하여알고리즘을기술함
- 프로그래밍언어 : 여러종류의언어로알고리즘을구현함
- 의사코드(pseudo code) : 프로그래밍언어에의존하지않고알고리즘을기술할수있음

자료구조

- 데이터를어떠한형태로저장하고관리할것인지에대한방법
- 어떻게효율적으로자료를저장할것인가에대한고민

알고리즘

- 저장된데이터를찾거나변형및수정할때필요한방법
- 문제를해결하기위한절차에대한고민

자료구조

- 배열스택큐링크드리스트힙해쉬테이블

알고리즘

- 정렬탐색동적그래프탐욕분할정복백트레킹

프로그램

- 컴퓨터에서실행될때특정작업을수행하는일련의명령어들의집합
- 프로그램=자료구조+알고리즘

프로그램 작성에서의 알고리즘

- 프로그램설계하기 - 알고리즘은프로그램에서설계서에해당됨
- 프로그래밍 - 알고리즘이결정되었다면코딩을해야함, 코딩은프로그래밍언어를사용하여알고리즘을만들어가는과정
- 프로그램디버깅 - 디버그(Debug) : 오류를찾아수정하는작업
- 프로그램문서작성 -프로그램을완성한후에는문서(document)를 작성함

알고리즘의 성능분석

- 처리시간측정
- 2개의알고리즘의실제처리시간을측정함
- 실제구현을하여테스트를함
- 동일한하드웨어를사용해야함

알고리즘의 복잡도 분석

- 직접구현하지않고서도처리시간을분석할수있음
- 알고리즘이수행하는연산의횟수를측정하여비교함
- 연산의횟수는n의함수
- 시간복잡도분석(time complexity) - 처리시간분석
- 공간복잡도분석(space complexity) - 처리시필요로하는메모리공간분석
- 시간복잡도는알고리즘에서연산들이몇번수행되는지를숫자로표시함
- 연산의수행횟수는입력의개수n에대한함수T(n)으로표기함
- 알고리즘이수행하는연산의개수를계산하여두개의알고리즘을비교함

### 빅오 표기법

빅오(Big-oh) 표기법

- 연산횟수로측정하는표기법
- 입력크기n에대해계산횟수가어느정도인지를표현함
- 점근표기법으로알고리즘의수행시간을대략적으로나타냄
- 예)
- input n에대해계산횟수가일정함 : O(1)
- input n에대해n과계산횟수가비례함 : O(n)
- input n에대해계산횟수가제곱으로증가함 : O(n²)
- 자료의개수가많은경우는차수가가장큰항이가장큰영향을크게미치고다른항들은상대적으로무시될수있음
- 가장영향을크게미치는항만을고려하면충분함
- best, average, worst의경우알고리즘의수행시간은입력자료집합에따라다를수있음



## 2. 배열

자료 구조 배열
- 데이터를 나열하고, 각 데이터를 인덱스에 대응하도록 구성한 데이터 구조
- 같은 종류의 데이터를 효율적으로 관리하기 위해 사용
- 같은 종류의 데이터를 순차적으로 저장하기 위해 사용
- 장점 - 빠른 접근이 가능함 • 첫 데이터의 위치에서 상대적인 위치로 데이터 접근(인덱스 번호로 접근)
- 단점 ‐ 데이터 추가/삭제가 어려움 • 미리 최대 길이를 지정해야 함

Primitive 자료형과 Wrapper 클래스
- JAVA에서는 int와 integer와 같이, Primitive 자료형과 Wrapper 클래스가 있음
- Wrapper 클래스를 주로 사용함

Wrapper 클래스 사용하는 이유
- Null을 용이하게 처리할 수 있음
- ArrayList 등 객체만을 핸들링 하는 기능을 사용하기 위함

배열이란?
- 같은 자료형의 변수로 이루어진 구성 요소(Component)가 모인 것

배열의 선언
- int형인 배열임을 명확하게 나타내는 타입 A가 많이 사용됨
- int[] a; //a는 자료형이 int형인 배열 : 타입 A
- int a[]; //a는 자료형이 int형인 배열 : 타입 B

구성 요소의 수가 5개인 배열은 아래와 같이 선언됨
- A = new int[5]; //a는 길이가 5인 배열을 참조함

배열 변수와 배열 본체
- 배열은 같은 형의 구성 요소가 직선 모양으로 연속하여 줄지어 있는 단순한 구조로 되어 있음

배열의 특성 실습
```java
class IntArray
{
public static void main(String[] args) {
int[] a = new int[5]; // 배열의 선언
a[1]=37;
a[2]=51;
a[4]=a[1]*2;
for(int 
i=0;i<a.length;i++)
System.out.println("a[" +
i+ "]=" +a[
i]);
}
}
```

배열의 값을 초기화하며 배열 선언하기
- 배열 본체
- 배열 초기화(array initializer)를 사용하면 배열 본체의 생성과 동시에 각 요소의 초기화가 가능함

배열 값의 최댓값 구하기 예제
배열 값을 역순으로 정렬하기 예제
다차원 배열
2차원 배열 
int[][] x = new int [2][4];
3차원 배열
Int y [][][] = new long [2] [4];
int y [][][] = new long [2][3][4];

## 3. 스택과 큐

스택(stack)

스택이란?
- 데이터를 일시적으로 쌓아 놓는 자료구조

데이터의 입력과 출력 순서
- LIFO(Last In, First Out)
- 가장 나중에 넣은 데이터를 가장 먼저 추출하는 정책

스택의 활용의 예
- 컴퓨터 내부 프로세스 구조의 함수 동작 방식
- 재귀 프로그램

주요 기능
- push() : 스택에 데이터를 넣는 작업
- pop() : 스택에서 데이터를 꺼내는 작업

메서드 호출과 스택
- 자바 프로그램에서 메서드를 호출하고 실행할 때 내부에서 스택을 사용함

```java
void x() { /*…*/ }
void y() { /*…*/ } 
void z() {
x();
y();
}
void main() {
z();
}
```

1 main 메서드가 실행되기 전의 상태
2 main 메서드가 호출되어 실행을 시작
3 z 메서드를 호출
4 x 메서드를 호출함
5 x 메서드가 실행을 종료하고, z 메서드로 돌아옴
6 y 메서드를 호출함
7 y 메서드가 실행을 종료하고 z 메서드로 돌아옴
8 z 메서드가 실행을 종료하고 main 메서드로 돌아옴
9 main 메서드가 실행을 종료함

장 · 단점
- 장점
- 구조가 단순하여 구현이 용이함
- 데이터의 저장/읽기 속도가 빠름
- 단점
- 데이터의 최대 개수를 미리 정해야 함
- 저장 공간의 낭비가 발생함
‐ 사용하려는 데이터의 최대 개수만큼 저장 공간을 확보해야 함
- 스택은 빠른 성능을 위해 사용되므로, 배열을 활용해 구현하는 것이 일반적임

스택의 push 알고리즘
 top ← top+1;
‐ 스택에서 top이 마지막 데이터를 가리키고 있으므로 그 위에 자료를 삽입하려면 먼저 top의 위치를 하나 증가시킴
‐ 이때 top의 위치가 스택의 크기(stack_size)보다 크다면 오버플로우(overflow) 상태가 되므로 삽입 연산을 수행하지 못하고 연산이 종료됨
 stack(top) ← x;
‐ 오버플로우 상태가 아니라면 스택의 top이 가리키는 위치에 x를 삽입함

스택의 pop 알고리즘
 return stack(top);
‐ 비어있는 스택이 아니라면 top이 가리키는 데이터를 먼저 반환함
 top ← top-1;
‐ 스택의 top 데이터를 반환하였으므로 top의 위치는 그 아래 데이터로 변경하기 위해 top의 위치를 하나 감소함

배열을 사용한 스택 구현
- 순차 자료구조인 배열을 사용하여 스택을 구현함
- 스택의 사이즈 : 배열의 사이즈
- 스택에 저장된 데이터의 순서 : 배열 데이터의 인덱스
- 인덱스 0번 : 스택의 첫번째 데이터
- 인덱스 n-1번 : 스택의 n번째 데이터
- 변수 top : 스택에 저장된 마지막 데이터에 대한 인덱스 저장
- 공백 상태 : top = -1(초기값)
- 포화 상태 : top = n-1

스택의 search 알고리즘

```java
Stack<integer> stack = new Stack<>();
for (int i = 0; i <5; i++) {
stack.push(i + 1);
}
System.out.println(stack.search(1));
```

큐(queue)

- 스택과 마찬가지로 데이터를 일시적으로 쌓아 두는 기본 자료구조
- 가장 먼저 넣은 데이터를 가장 먼저 꺼내는 선입선출 구조
- 영화관에서 가장 먼저 줄을 선 사람이 먼저 입장하는 것과 동일함
- FIFO(First-In, First-Out) 방식으로 스택과 꺼내는 순서가 반대임
- 너비 우선 탐색(BFS), 캐시(cache) 구현

큐의 연산
- Enqueue : 큐에 데이터를 넣는 작업
- Dequeue : 큐에 데이터를 꺼내는 작업

스택과 큐의 비교

스택
- Last in, First out
- push top pop top

큐
- First in, First out
- enQueue rear deQueue front

배열로 큐 만들기
- 스택과 마찬가지로 큐 또한 배열을 사용하여 구현할 수 있음

링 버퍼로 큐 만들기
- 배열 요소를 앞쪽으로 옮기지 않는 큐
- 이를 위해 사용하는 자료구조를 ‘링 버퍼(ring buffer)’라고 함
- 배열의 맨 뒤가 맨 앞과 연결되었다고 보는 자료구조
- 프런트(front) : 논리적으로 맨 앞 요소의 인덱스
- 리어(rear) : 논리적인 맨 뒤 요소 하나 뒤의 인덱스(다음 요소를 인큐할 위치의 인덱스)
- 인큐와 디큐를 수행하면 변수 프런트값과 리어값이 다음과 같은 과정을 거쳐 변화함

## 4. 리스트

1) 리스트(list)란?

- 순서를 가지고 일렬로 나열한 항목(item)들의 모임
- 집합 - 항목 간의 순서의 개념이 없음
- 리스트 - 순서를 갖도록 데이터를 나열한 것임

2) 구조

선형구조 
- 스택(Stack)
- 데크(Deque)
- 큐(Queue) 
- 리스트

리스트
- 선형 리스트(Linear List)
- 연결 리스트(Linked List)

- 임의의 위치에서도 삽입과 삭제가 가능함

3) 종류

- 데이터가 배열처럼 연속하는 메모리 공간에 저장되어 순서를 가짐
- 데이터가 메모리 공간에 연속적으로 저장되어 있지 않더라도 각각의 데이터 안에 다음 데이터에 대한 정보를 갖고 있어 서로 연결됨
- 선형 리스트 연결 리스트

4) 연결 리스트의 장단점

장점
• 데이터를 넣을 공간을 미리 할당하지 않아도 됨

단점
• 연결을 위한 별도의 데이터 공간이 필요함
• 연결 정보를 찾는 시간이 필요하며, 접근 속도가 느림
• 중간의 데이터가 삭제되면 앞뒤 데이터를 연결해야 하는 또 다른 작업이 필요함

리스트 구현
- 배열을 이용한 구현
- 연결 리스트를 이용한 구현

1) 배열로 선형 리스트 만들기
2) 포인터로 연결 리스트 만들기
3) 원형 리스트(Circular linked list)
4) 이중 연결 리스트(Double linked list)
5) 원형 이중 연결 리스트 구현

## 5. 재귀 알고리즘

1) 재귀(recursive)란?

- 자기 자신의 함수 호출을 재귀 호출(recursive call)이라 하며, 이러한 특징을 재귀(recursion)라 함
- 되부름 또는 순환이라 표현됨
- 재귀 함수(recursive function) - 함수가 정의 될 때 자기 자신의 함수를 호출이 가능함

2) 재귀(recursive) 함수의 특징


- 1 알고리즘이 재귀적 특성을 갖는다면, 재귀 함수를 통해 쉽게 구현이 가능함
- 2 재귀 함수를 이용하면 보다 쉽게 문제해결을 할 수 있음
- 3 계속적인 함수 호출로 인해 시간과 메모리 공간의 효율성이 떨어짐
- 4 일반적으로 반복문을 이용한 함수로 변환이 가능함

3) 재귀(recursive) 알고리즘이란?

- 함수의 형태로 많이 사용됨
- 재귀를 효과적으로 사용하면 프로그램을 간결하고 효율성 있게 작성할 수 있음

4) 재귀 알고리즘의 속성 및 사용 방법

재귀 알고리즘의 속성
- 어떤 사건을 해결하기 위해 사건의 범위보다 약간 좁은 하위 문제를 해결함
- 재귀 알고리즘의 호출은 더 이상 반복되지 않을 때까지 계속됨

재귀 알고리즘의 사용 방법
- 먼저 반복되는 작업을 찾음
- 반복되는 작업을 함수로 작성하고 입력값과 결과값의 형식을 결정함
‐ 입력값은 한 단계씩 점진적으로 변하며, 마지막으로 더 이상 변화가 없는 입력값은 종료 조건으로 사용됨

5) 팩토리얼(n!) 구하기

- 재귀를 사용한 예로 음이 아닌 정수 n의 팩토리얼(n!)을 구하는 프로그램
- 음이 아닌 정수 n의 팩토리얼 값을 반환

6) 직접 재귀와 간접 재귀

- 직접 재귀 - 자신과 동일한 메서드를 호출하는 것
- 간접 재귀 - 메서드 a가 메서드 b를 호출하고, 다시 메서드 b가 메서드 a를 호출하는 구조로 이루어지는 것

재귀 알고리즘에 알맞은 경우는?
- 풀어야 할 문제 계산할 메서드 처리할 자료구조
- 위의 사항들이 재귀로 정의되는 경우

7) 유클리드 호제법

- 두 정수의 최대공약수를 재귀적으로 구하는 방법
- 직사각형을 정사각형으로 빈틈없이 채우고 이렇게 만들어지는 정사각형
- 두 정수의 최대공약수를 재귀적으로 구하는 방법

### 재귀 알고리즘 분석

1) 재귀 알고리즘 분석하기

1 recur 메서드를 통한 분석

```java
static void recur(int n) {
if(n > 0)
recur(n-1);
System.out.println(n);
recur(n-1);
}
```

2 하향식 분석
- 메서드를 호출하는 것부터 시작하여 계단식으로 자세히 조사해 나가는 분석 기법

3 상향식 분석
- 아래쪽부터 쌓아 올리며 분석하는 방법이 상향식 분석 기법

2) 하향식 분석

3) 상향식 분석

### 하노이의 탑

1) 쌓아둔 원반을 최소 횟수로 옮기기 위한 알고리즘

2) 하노이의 탑 아이디어(원반 3개)

3) 하노이의 탑 아이디어(원반 2개)

4) 하노이의 탑 아이디어(원반 4개)

5) 원반이 3일 때 move 메서드의 동작

## 6. 정렬 알고리즘

1) 정렬이란?

정렬(sorting) 
- 이름, 학번, 키 등 핵심 항목(key)의 대소 관계에 따라 데이터 집합을 일정한 순서로 나열하는 작업
- 정렬 알고리즘을 이용해 데이터를 정렬하면 검색을 더 쉽게 할 수 있음

2) 정렬 알고리즘의 안정성


안정된 정렬
- 정렬 알고리즘은 안정된 알고리즘과 그렇지 않은 알고리즘으로 나눌 수 있음
- 안정된 정렬 - 키 값이 같은 요소의 순서가 정렬 전후에도 유지되는 것

3) 내부 정렬과 외부 정렬

- 정렬 알고리즘에서 내부 정렬과 외부 정렬을 사용함
- 내부 정렬 - 정렬할 모든 데이터를 하나의 배열에 저장할 수 있을 때에 사용하는 알고리즘 
- 외부 정렬 - 정렬할 데이터가 너무 많아서 하나의 배열에 저장할 수 없을 때에 사용하는 알고리즘

4) 정렬 알고리즘의 핵심 요소

- 교환, 선택, 삽입
- 대부분의 정렬 알고리즘은 이 3가지 요소를 응용한 것임

### 버블 정렬

1) 버블 정렬 알아보기

- 이웃한 두 요소의 대소 관계를 비교하고 필요에 따라 교환을 반복하는 알고리즘으로 단순 교환 정렬이라고도 함

- 배열을 이용한 버블 정렬
- 먼저 끝에 있는 두 요소 9와 8부터 시작함
- 배열을 오름차순으로 정렬하고자 한다면 왼쪽 값이 오른쪽 값보다 작아야 함
- 9와 8을 교환한 배열은 다음과 같음
- 이웃한 요소를 비교하고 교환하는 작업을 첫 번째 요소까지 계속하면 다음과 같음

3) 알고리즘 개선하기

### 단순 선택 정렬 

1) 단순 선택 정렬

- 가장 작은 요소를 맨 앞으로 이동하고, 두 번째 작은 요소는 맨 앞에서 두 번째로 이동하는 등의 작업을 반복하는 알고리즘
- 앞에서 진행한 작업을 반복하는 과정으로, 아직 정렬하지 않은 부분에서 값이 가장 작은 요소를 선택하고 아직 정렬하지 않은 부분의 첫 번째 요소와 교환함
- 아직 정렬하지 않은 부분에서 값이 가장 작은 요소 아직 정렬하지 않은 부분의 첫 번째 요소 정렬을 아직 정렬하지 않음
- 마침

선택 정렬 복잡도 분석
- 비교 횟수 : (n-1)+(n-2)+…+1 = n(n-1)/2 = O(n2)
- 이동 횟수 : 3(n - 1)
- 전체 복잡도 : O(n2), 안정성을 만족하지 않음

2) 단순 삽입 정렬

- 단순 삽입 정렬은 트럼프 카드를 한 줄로 늘어놓을 때 사용하는 방법과 비슷한 방법의 알고리즘임
- 단순 삽입 정렬은 두 번째 요소부터 선택하여 진행함 
- 선택한 요소를 그보다 더 앞쪽의 알맞은 위치에 ‘삽입하는’ 작업을 반복하여 정렬하는 알고리즘

삽입 정렬 복잡도 분석
- 최선의 경우 O(n) 이미 정렬되어 있는 경우,  비교 : n-1 번
- 최악의 경우 O(n2) 역순으로 정렬되어 있는 경우
- 평균의 경우 O(n2)

삽입 정렬 복잡도 분석
- 1 많은 이동이 필요함 -  레코드가 클 경우 불리함
- 2 안정된 정렬 방법 - 3 대부분 정렬이 되어 있다면 매우 효율적임

- 버블 정렬, 단순 선택 정렬, 단순 삽입 정렬
- 세 가지 단순 정렬 시간 복잡도는 모두 O(n2)임(효율이 좋지 않음)

### 셸 정렬, 퀵 정렬

1) 셸 정렬(shell sort)

- 단순 삽입 정렬의 장점을 살리고 단점을 보완하여 좀 더 빠르게 정렬하는 알고리즘

장점
- 정렬이 되었거나 또는 그 상태에 가까우면 정렬 속도가 아주 빠름

단점
- 삽입할 곳이 멀리 떨어지면 이동(대입)하는 횟수가 많음
- 단순 삽입 정렬의 장점을 살리고 단점을 보완한 정렬 알고리즘으로, 도날드 셸이 고안함 정의 먼저 일정한 간격으로 서로 떨어져 있는 두 요소를 그룹으로 묶어 대략 정렬을 수행하고, 간격을 좁혀
그룹의 수를 줄이면서 정렬을 반복하여 요소의 이동 횟수를 줄이는 방법임
 
- 아직 정렬을 마친 상태는 아니지만 정렬을 마친 상태에 가까워지고 있음 • 4칸 떨어진 요소를 하나의 그룹으로 묶어 정렬하는 방법을 셸 정렬’이라고 함

2) 퀵 정렬(quick sort)

퀵 정렬의 특징 살펴보기
- 퀵 정렬은 일반적으로 폭넓게 사용되고 있는 아주 빠른 정렬 알고리즘임
- 퀵 정렬은 이 알고리즘을 개발한 찰스 앤터니 리처드 호어가 알고리즘의 정렬 속도가 매우 빠른 데서 착안하여 직접 붙인 이름임
- 퀵 정렬은 분할 정복(devide and conquer)에 기반한 알고리즘을 사용함

퀵 정렬의 시간 복잡도 구하기
- 퀵 정렬은 배열을 차례로 나누어 보다 작은 문제를 해결하는 과정을 반복하므로 시간 복잡도는 O(n log n)임
- 최악의 시간 복잡도는 O(n2)이 됨

3) 병합 정렬(merge sorting)

병합 정렬
- 정렬을 마친 배열의 병합을 응용하여 분할 정복법에 따라 정렬하는 알고리즘
- 리스트를 두 개의 균등한 크기로 분할하고 분할된 부분 리스트를 정렬함
- 정렬된 두 개의 부분 리스트를 합하여 전체 리스트를 정렬함 
- 문제를 더 작은 2개의 문제로 분리하고 각 문제를 함 
- 결과를 모아 원래의 문제를 해결함
- 분리된 문제에서 해결이 어렵다면 분할 정복 방법을 다시 적용함
- 분할 정복(divide and conquer) 방법 사용


- 1 분할 (divide) - 배열을 같은 크기의 2개의부분 배열로 분할함
- 2 정복 (conquer) - 부분 배열을 정렬함 부분 배열의 크기가 작지 않으면 재귀호출을 사용하여 다시 분할정복 방법을 적용함
- 3 결합 (Combine) - 정렬된 부분 배열을 하나의 배열에 통합

병합 정렬 복잡도 분석
- 비교 횟수
- 크기가 n인 리스트를 정확히 균등 분배하므로 log(n) 개의 패스
- 각 패스에서 리스트의 모든 레코드 n개를 비교하므로 n번의 비교 연산
- 이동 횟수
- 각 패스에서 2n번 발생하므로 전체 이동은 2n*log(n)번 발생함
- 요소의 크기가 큰 경우는 매우 큰 시간이 낭비됨
- 최적, 평균, 최악의 경우 큰 차이 없이 O(n * log(n))의 복잡도
- 안정적이며 데이터의 초기 분산 순서에 영향을 덜 받음

## 7. 해쉬

1) 개요

해시법이란?
- 검색뿐만 아니라 데이터의 추가와 삭제도 효율적으로 수행할 수 있는 방법
- 해시법은 데이터를 저장할 위치(인덱스)를 간단한 연산으로 구하여 검색, 추가, 삭제를 효율적으로 수행
- 해시값을 인덱스로 하여 원래의 키값을 저장한 배열을 해시 테이블(hash table)이라 함

2) 해시 테이블(hash table)

- 키(key)를 통해 데이터를 받아올 수 있으므로 속도가 빠름
- 배열로 해시 테이블을 생성한 후에 사용함
- 여러 키에 해당하는 주소가 동일하면 충돌을 해결하기 위해 해시 테이블의 공간을 늘려야 함
- 키값(35)을 해시값(9)으로 변환하는 과정을 해시 함수(hash function)라고 함

3) 해시 함수(hash function)

- 일반적으로 키들은 부여된 의미나 특성을 가짐
- 키의 앞 부분 또는 뒤에 몇 자리를 취해 해시값으로 사용하는 방식은 많은 충돌을 야기함
- 가장 이상적인 해시 함수는 키들을 균등하게(uniformly) 해시 테이블의 인덱스로 변환하는 함수임
- 균등하게 변환한다는 것은 키들을 해시 테이블에 랜덤하게 저장하는 것을 의미함
- 해시 함수는 키들을 균등하게 해시 테이블의 인덱스로 변환하기 위해 단순 계산을 통해 해시 테이블의 크기에 맞도록 해시값을 계산함
- 아무리 균등한 결과를 보장하더라도 함수를 연산하는데 시간이 많이 소요된다면 신속성이 보장되지 않아 해싱의 장점을 잃음

### 종류
- 1 중간 제곱(mid-square) 함수 - 키를 제곱한 후, 적절한 크기의 중간부분을 해시값으로 사용함
- 2 접기(folding) 함수 - 십진수를 키로 사용할 때, 일정한 숫자들의 합을 이용해 해시값을 만듦
- 3 곱셈(multiplicative) 함수 
- 1보다 작은 실수 𝛿를 키에 곱하여 얻은 값에서 소수부분을 테이블 크기 M과 곱함. 
- 이 값의 정수 부분을 해시값으로 사용함
- 키의 값들이 함수의 계산에 관여하기 때문에 결과에서 원래 키에 부여된 특성을 찾아 볼 수 없음
- 해시 테이블의 크기에 따라 특정 부분만을 해시값으로 활용함 
- 4 나눗셈(division) 함수
- 키를 소수로 나누고 그 나머지를 해시값으로 사용함
- 나눗셈 연산을 수행했을 때, 소수가 키들을 균등하게 인덱스로변환 시키는 성질을 가지기 때문에 소수를 사용함
- 가정 널리 사용되는 해시 함수임

4) 해싱의 개념

- 성능이 좋은 해시 함수를 사용하더라도 2개 이상의 항목을 해시 테이블의 동일한 원소에 저장해야 하는 경우가 발생함
- 서로 다른 키들이 동일한 해시값을 가질 때 충돌(collision)이 발생함

5) 해시 테이블의 장 ·단점과 용도

장점
- 데이터 저장/읽기 속도가 빠름
- 해시는 키에 대한 중복 확인이 용이함

단점
- 여러 키에 해당하는 주소가 동일할 경우 충돌 해결을 위한 별도의 방법이 필요함
- 저장, 삭제, 읽기가 빈번한 경우 검색이 많이 필요한 경우 많은 저장 공간을 필요로 함 


6) 충돌(collision)

- 해시 테이블의 가장 큰 문제는 무엇인가?
- 충돌의 경우로, 이 문제를 충돌 또는 해시 충돌(hash collision)이라고 함
- 성능이 좋은 해시 함수를 사용해도 2개 이상의 항목을 해시 테이블의 동일한 원소에 저장해야 하는 경우가 발생함
- 이때, 서로 다른 키들이 동일한 해시 값을 가질 때 충돌이 발생함 

충돌 대처법
- 충돌이 발생할 때 다음 2가지 방법으로 대처할 수 있음

체인법
- 해시값이 같은 요소를 연결 리스트로 관리함 

오픈 주소법
- 빈 버킷을 찾을 때까지 해시를 반복함

닫힌 주소법(close addressing)
- 해시 테이블 저장공간 안에서 충돌 문제를 해결하는 기법
- 충돌이 발생하면 해당 해시 주소의 다음 주소부터 맨 처음 나오는 빈공간에 저장하는 기법
‐ 저장공간의 활용성을 높기 위한 방법
- 충돌이 발생했을 때 재 해시를 수행하여 비어 있는 버킷을 찾아내는 방법
- 충돌이 발생한 키들은 한 위치에 모아서 저장함
- 가장 대표적인 방법은 chaining

체인법(chaining)
- 개방 해시법 또는 오픈 해시법(open hashing)이라고도 함
- 해시값이 같은 데이터를 사슬 모양의 연결 리스트로 연결하는 방법
- 해시 테이블 저장공간 외의 공간을 활용함
- 각 버킷에 저장하는 값은 ‘해시값이 같은 노드를 연결한 리스트’의 첫 번째 노드를 참조함
- 요소를 검색(search)

오픈 주소법(open addressing)
- 오픈 주소법은 충돌이 발생했을 때 재해시(rehashing)를 수행하여 비어 있는 버킷을 찾아내는 방법임
- 해시 테이블 전체를 열린 공간으로 가정하고 충돌된 키를 일정한 방식에 따라서 찾아낸 빈 공간에 저장함
- 닫힌 해시법(closed hashing)이라고도 함
- 대표적인 개방주소방식 - 선형조사(linear probing), 이차조사(quadratic probing), 랜덤조사(random probing), 이중해싱(double hashing)

- 요소 삽입
‐ 새로운 값(18)을 삽입하고자 할 때 충돌이 발생한 경우 • 이럴 때 사용하는 방법을 재해시라 함
• 재해시를 할 때 해시 메서드는 자유롭게 결정할 수 있음 • 키값에 1을 더한 값을 13으로 나눈 나머지로 함

- 충돌 - 재해시했지만 다시 충돌 다시 재해시하고 삽입
- 해시의 개념 - 오픈 주소법(open addressing)
- 요소 삽입 - 오픈 주소법은 빈 버킷을 만날 때까지 재해시를 여러 번 반복하므로 선형 탐사법이라고도 함
- 요소 삭제 ‐ 인덱스가 5인 버킷의 데이터를 비우면 될 것 같지만 실제로는 그렇게 간단하지 않음
- 인덱스가 5인 버킷을 그냥 비워 두면 해시값이 같은 18을 검색할 때 ‘해시값이 5인 데이터는 존재하지 않는다’라고 생각하여 검색에 실패하기 때문임

7) 개방주소방식의 종류

- 랜덤조사(random probing)
- 이중해싱(double hashing) -  이차조사는 이웃하는 빈 곳이 채워져 만들어지는 1차 군집화 문제를 해결함
- 선형조사(linear probing)
- 이차조사(quadratic probing) 
- 같은 해시 값을 가지는 서로 다른 키들인 동의어(sysnonym)들이 똑같은 점프 시퀀스(jump sequence)를 따라 빈 원소를 찾아 저장함
- BUT  결국 다른 형태의 군집화인 2차 군집화(sencond clustering)를 야기함
-  점프의 크기가 제곱 크기만큼 커지므로 배열에 빈 요소가 있음에도 빈 요소를 건너뛰어 탐색에 실패하는 사례도 발생함
 랜덤조사는 선형, 이차조사의 규칙적인 점프 시퀀스와는 달리 랜덤을 도입해 빈 요소를 찾는 충돌해결 방법임
 의사 난수(pseudo random) 생성기를 사용해 다음 위치를 검색함
 동의어들이 같음에 따른 점프 시퀀스에 따라 빈 요소들을 찾아 키를 저장하기 때문에 3차 군집화(tertiary clustering)가 발생함
 2개의 해시 함수를 사용함
 기본적인 해시 함수로 키를 해시 테이블의 인덱스로 변환하고, 충돌이 발생하면 다음 위치를 위한 점프 크기를 아래의 규칙과 같이 규정함
 이중해싱은 동의어들마다 2의 해시 함수를 가지고 때문에 점프 시퀀스가 일정하지 않음
 2 함수는 d(key)는 점프 사이즈를 정하는 함수라 0을 리턴해서는 안됨
 d(key)의 값과 해시 테이블의 크기 M과 서로 소(relatively prime)관계일 때 더 좋은 성능을 보임
‐ 해시 테이블 크기를 소수로 정하면 이 제약 조건을 만족함

8) 해시 관련 정리

- 키를 배열의 인덱스로 그대로 사용하면 메모리 낭비가 심해질 수 있음
- 키를 변환하여 배열의 인덱스로 사용함
- 키를 단순한 함수를 사용해 변환한 값을 배열의 인덱스로 사용해 항목을 저장하는 것
해싱(hashing)
해싱에 사용되는 함수 해시 함수(hash function)
해시 함수가 계산한 값 - 해시 값(hash value) 또는 해시 주소
항목이 해시값에 따라 저장되는 배열 해시 테이블(hash table)
한 개의 데이터를 저장할 수 있는 공간 슬롯(slot)

